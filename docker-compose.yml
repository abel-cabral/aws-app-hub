version: "3.8"

services:
  # ---------------------------- CONFIGURE AQUI SUAS APLICAÇÕES ---------------------------- #
  simple-sum:
      image: ozteps/simple-sum:latest # Substitua "ozteps/simple-sum:latest" pela imagem da sua própria aplicação. Pode ser qualquer imagem do Docker Hub ou de um registro privado.
      deploy:
        replicas: 1 # Define que apenas 1 réplica (contêiner) da aplicação será executada.
        update_config:
          parallelism: 1 # Atualiza 1 contêiner por vez ao fazer o update.
          delay: 10s # Espera 10 segundos entre a atualização de cada contêiner.
        resources:
          limits:
            memory: 32M # Limite de memória para o contêiner. Ajuste conforme a necessidade da sua aplicação.
            # Atenção: definir pouca memória para um serviço que precisa de muita pode fazer o contêiner falhar. 
      ports:
        - "9001:80" # Mapeia a porta 9001 no host para a porta 80 no contêiner, permitindo o acesso à aplicação via http://host:9001.

  # ---------------------------- SERVIÇOS COMPLEMENTARES ----------------------------------- #

  # REMOVE IMAGENS E CONTÊINERES QUE NÃO ESTÃO EM USO
  cleaner:
    image: alpine:latest # Usa uma imagem leve baseada em Alpine Linux.
    deploy:
      replicas: 1 # Apenas 1 réplica do serviço será executada.
      resources:
        limits:
          memory: 32M # Limita o uso de memória do contêiner a 32 MB.
    command: /bin/sh -c "apk add --no-cache docker-cli && while true; do docker system prune -af --filter 'until=24h'; sleep 3600; done"
    # Comando que instala o cliente Docker dentro do contêiner e, em seguida, executa a limpeza automática de imagens e contêineres
    # não utilizados a cada hora (3600 segundos), removendo aqueles que não foram usados nas últimas 24 horas.
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock # Conecta o contêiner ao socket Docker do host, permitindo que o contêiner limpe os recursos do Docker no host.

  # MONITORA QUANDO UMA NOVA IMAGEM É PUBLICADA NO DOCKER HUB
  watchtower:
    image: containrrr/watchtower # Usa a imagem Watchtower, que monitora e atualiza contêineres quando uma nova versão da imagem é lançada.
    deploy:
      replicas: 1 # Apenas 1 réplica do serviço será executada.
      resources:
        limits:
          memory: 32M # Limita o uso de memória do contêiner a 32 MB.
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock # Conecta o contêiner ao socket Docker do host, permitindo que ele gerencie e atualize os contêineres.
    command: --interval 30 --cleanup # O Watchtower verifica atualizações a cada 30 segundos e remove automaticamente as imagens antigas.

  # CONFIGURA O PROXY REVERSO PARA PERMITIR O USO DE SUBDOMÍNIOS NA PORTA 80
  # nginx:
  #   image: nginx:latest # Usa a imagem mais recente do Nginx, que funciona como servidor web e proxy reverso.
  #   ports:
  #     - "80:80" # Mapeia a porta 80 do host para a porta 80 do contêiner, que é a porta padrão para acesso HTTP.
  #   volumes:
  #     - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro # Monta o arquivo de configuração personalizado do Nginx no contêiner.
  #   depends_on:
  #     - certbot # O Nginx só iniciará após o Certbot estar rodando, garantindo que certificados SSL estejam disponíveis.
  #   entrypoint: ["/bin/sh", "-c", "sleep 30 && nginx -g 'daemon off;'"] # Aguarda 30 segundos antes de iniciar o Nginx, garantindo que todos os serviços estejam prontos.

  # ---------------------------- EXEMPLO DE UM NOVO SERVIÇO -------------------------------- #

  # Adicione novos serviços aqui
  # lembre-se de:
  # 1. Substituir "minha-app" pelo nome do seu serviço
  # 2. Usar uma porta diferente de 9001 para evitar conflitos.
  # 3. Ajustar os limites de memória e outros recursos conforme necessário.

  # minha-app:
  #   image: minha-imagem:latest # Substitua "minha-imagem" pela imagem da sua aplicação.
  #   deploy:
  #     replicas: 1 # Executa uma única réplica da aplicação.
  #     resources:
  #       limits:
  #         memory: 64M # Ajuste o limite de memória conforme a necessidade da aplicação.
  #   ports:
  #     - "9002:80" # Mapeia a porta 9002 do host para a porta 80 do contêiner. Use uma porta diferente da usada em outros serviços.
